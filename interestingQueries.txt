Step 0: You invoke configure
cmake --preset=debug

Step 1: Configuration Pass

CMake:

Loads presets

Loads toolchain

Parses CMakeLists.txt

Executes all CMake code

find_package

FetchContent

compiler checks

build options

Builds the Target Dependency Graph

Writes build.ninja / Makefile

Step 2: Build Pass
cmake --build build


Backend compiles source code.


myproject/
├── CMakeLists.txt
├── CMakePresets.json
├── CMakeUserPresets.json (gitignored)
├── cmake/
│   ├── myproject.cmake.in
│   ├── myproject-config-version.cmake.in
│   └── Cache.cmake
├── include/myproject/
│   └── math.hpp
└── src/
    └── math.cpp

================================================================================
# CMakeLists.txt
================================================================================
cmake_minimum_required(VERSION 3.25)
project(myproject VERSION 1.0.0 LANGUAGES CXX)

# Load initial cache (sets defaults before first configure)
if(EXISTS ${CMAKE_SOURCE_DIR}/cmake/Cache.cmake)
    include(${CMAKE_SOURCE_DIR}/cmake/Cache.cmake)
endif()

# Library
add_library(myproject src/math.cpp)
target_compile_features(myproject PUBLIC cxx_std_20)
target_include_directories(myproject PUBLIC
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:include>
)

# Compiler warnings based on build type
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    target_compile_options(myproject PRIVATE
        $<$<CXX_COMPILER_ID:GNU,Clang>:-Wall -Wextra -Wpedantic>
        $<$<CXX_COMPILER_ID:MSVC>:/W4>
    )
endif()

# Optional: Add sanitizers in Debug
option(ENABLE_SANITIZERS "Enable address/UB sanitizers" OFF)
if(ENABLE_SANITIZERS AND CMAKE_BUILD_TYPE STREQUAL "Debug")
    target_compile_options(myproject PUBLIC -fsanitize=address,undefined)
    target_link_options(myproject PUBLIC -fsanitize=address,undefined)
endif()


================================================================================
# CMakePresets.json
================================================================================
{
  "version": 6,
  "cmakeMinimumRequired": {"major": 3, "minor": 25},
  "configurePresets": [
    {
      "name": "default",
      "hidden": true,
      "binaryDir": "${sourceDir}/build/${presetName}",
      "cacheVariables": {
        "CMAKE_EXPORT_COMPILE_COMMANDS": "ON"
      }
    },
    {
      "name": "debug",
      "inherits": "default",
      "displayName": "Debug Build",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "ENABLE_SANITIZERS": "ON"
      }
    },
    {
      "name": "release",
      "inherits": "default",
      "displayName": "Release Build",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Release"
      }
    },
    {
      "name": "relwithdebinfo",
      "inherits": "default",
      "displayName": "Release with Debug Info",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "RelWithDebInfo"
      }
    }
  ],
  "buildPresets": [
    {
      "name": "debug",
      "configurePreset": "debug"
    },
    {
      "name": "release",
      "configurePreset": "release",
      "configuration": "Release"
    }
  ]
}


================================================================================
# cmake/Cache.cmake
================================================================================
# Initial cache variables (applied before first configure)
# These are defaults that can be overridden by presets or -D flags

set(CMAKE_CXX_STANDARD 20 CACHE STRING "C++ standard")
set(CMAKE_CXX_STANDARD_REQUIRED ON CACHE BOOL "Require C++ standard")
set(CMAKE_CXX_EXTENSIONS OFF CACHE BOOL "Disable compiler extensions")

# Default to Release if not specified
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release CACHE STRING "Build type" FORCE)
endif()

# Build options
set(BUILD_SHARED_LIBS OFF CACHE BOOL "Build shared libraries")
set(ENABLE_SANITIZERS OFF CACHE BOOL "Enable sanitizers in Debug")


================================================================================
# Usage Examples
================================================================================

# Using presets (recommended)
cmake --preset=debug        # Configure debug build
cmake --build --preset=debug

cmake --preset=release      # Configure release build
cmake --build --preset=release

# Manual configuration (overrides Cache.cmake defaults)
cmake -B build -DCMAKE_BUILD_TYPE=Debug
cmake --build build

# Override cache variables
cmake -B build -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON

# Multi-config generators (Visual Studio, Xcode)
cmake -B build -G "Visual Studio 17 20


Notes:
CMAKE_INSTALL_PREFIX is for installing your project to the system (e.g., /usr/local).

Cache.cmake: Sets project-wide defaults before any configuration
Presets: Pre-configured build scenarios (debug/release/sanitizers)
Build Types: Control optimization level and debug info
Presets > CLI flags > Cache.cmake in precedence



For presets

1. Structure of configurePresets

Each entry describes how to run cmake -S … -B ….

(-S = Source directory → where your CMakeLists.txt lives
-B = Build directory → where CMake should generate build files (Ninja/Makefiles/etc.))

2. Structure of buildPresets

Each entry describes how to run cmake --build using a specific configure preset.

Should look like this:
{
  "version": 5,
  "cmakeMinimumRequired": { "major": 3, "minor": 23 },

  "configurePresets": [ ... ],

  "buildPresets": [ ... ],

  "testPresets": [ ... ]   // optional
}

Can also be specified like so: cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug
Presedence:
Highest → Lowest

Command-line -DVAR=value

Preset cacheVariables

-C <path>/Cache.cmake (initial cache seed file)

Existing CMakeCache.txt

Defaults in CMakeLists.txt

So: CLI overrides presets, presets override -C, -C seeds the initial cache before CMakeCache.txt, and CMakeLists is last.


When you run cmake -S . -B build --preset debug:

It uses the configure preset named "debug"
Build presets are used later with cmake --build build --preset debug
The build preset references a configure preset because you must configure before you can build.
The "configurePreset": "debug" tells CMake: "when using this build preset, make sure the project was configured with the debug configure preset."
It's a consistency check - ensures you're building what you think you're building







Spdlog:

// If async logger:
queue_.push(msg);  // Background thread writes to file
```

## Architecture:
```
┌─────────────────────────────────────────┐
│         Your Code                       │
│  spdlog::info("x={}", 42)              │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│         spdlog                          │
│  - Check log level                     │
│  - Add timestamp                       │
│  - Add thread ID                       │
│  - Format message with fmt: ────────┐  │
└─────────────────────────────────────┼──┘
                                      │
                                      ▼
                           ┌──────────────────┐
                           │   fmt::format    │
                           │  "x={}" + 42     │
                           │  → "x=42"        │
                           └────────┬─────────┘
                                    │
                                    ▼ (returns formatted string)
┌─────────────────────────────────────────┐
│         spdlog (continued)              │
│  - Create full log line:               │
│    "[2024-11-15 14:32:10] [info] x=42" │
│  - Send to sinks:                      │
│    ├─ Console sink → stdout            │
│    ├─ File sink → app.log              │
│    └─ Rotating file sink → app1.log    │
└─────────────────────────────────────────┘



When is typename actually needed?
Because typename is only required when the type depends on a template parameter and might not be a type without telling the compiler.

When typename IS required

Example with iterators:

template <typename T>
void f(T it) {
    typename T::value_type x;   // depends on T → compiler needs help
}


You said:
{:5d} → Width 5, right-aligned

{:05d} → Zero-pad (e.g., 00042)

short res what's the difference? and show a short example of {:>5} → Right-align

{:<5} → Left-align

{:^5} → Center

{:*^5} → Center, fill * short res